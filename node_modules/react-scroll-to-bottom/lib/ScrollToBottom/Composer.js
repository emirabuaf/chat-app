"use strict";

Object.defineProperty(exports, "__esModule", {
  value: true
});
exports.default = void 0;

var _memoizeOne = _interopRequireDefault(require("memoize-one"));

var _propTypes = _interopRequireDefault(require("prop-types"));

var _react = _interopRequireDefault(require("react"));

var _simpleUpdateIn = _interopRequireDefault(require("simple-update-in"));

var _EventSpy = _interopRequireDefault(require("../EventSpy"));

var _FunctionContext = _interopRequireDefault(require("./FunctionContext"));

var _InternalContext = _interopRequireDefault(require("./InternalContext"));

var _SpineTo = _interopRequireDefault(require("../SpineTo"));

var _StateContext = _interopRequireDefault(require("./StateContext"));

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }

function _typeof(obj) { if (typeof Symbol === "function" && typeof Symbol.iterator === "symbol") { _typeof = function _typeof(obj) { return typeof obj; }; } else { _typeof = function _typeof(obj) { return obj && typeof Symbol === "function" && obj.constructor === Symbol && obj !== Symbol.prototype ? "symbol" : typeof obj; }; } return _typeof(obj); }

function _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; var ownKeys = Object.keys(source); if (typeof Object.getOwnPropertySymbols === 'function') { ownKeys = ownKeys.concat(Object.getOwnPropertySymbols(source).filter(function (sym) { return Object.getOwnPropertyDescriptor(source, sym).enumerable; })); } ownKeys.forEach(function (key) { _defineProperty(target, key, source[key]); }); } return target; }

function _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }

function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

function _defineProperties(target, props) { for (var i = 0; i < props.length; i++) { var descriptor = props[i]; descriptor.enumerable = descriptor.enumerable || false; descriptor.configurable = true; if ("value" in descriptor) descriptor.writable = true; Object.defineProperty(target, descriptor.key, descriptor); } }

function _createClass(Constructor, protoProps, staticProps) { if (protoProps) _defineProperties(Constructor.prototype, protoProps); if (staticProps) _defineProperties(Constructor, staticProps); return Constructor; }

function _possibleConstructorReturn(self, call) { if (call && (_typeof(call) === "object" || typeof call === "function")) { return call; } return _assertThisInitialized(self); }

function _getPrototypeOf(o) { _getPrototypeOf = Object.setPrototypeOf ? Object.getPrototypeOf : function _getPrototypeOf(o) { return o.__proto__ || Object.getPrototypeOf(o); }; return _getPrototypeOf(o); }

function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function"); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, writable: true, configurable: true } }); if (superClass) _setPrototypeOf(subClass, superClass); }

function _setPrototypeOf(o, p) { _setPrototypeOf = Object.setPrototypeOf || function _setPrototypeOf(o, p) { o.__proto__ = p; return o; }; return _setPrototypeOf(o, p); }

function _assertThisInitialized(self) { if (self === void 0) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return self; }

var MIN_CHECK_INTERVAL = 17;

function setImmediateInterval(fn, ms) {
  fn();
  return setInterval(fn, ms);
}

function computeViewState(_ref) {
  var mode = _ref.stateContext.mode,
      _ref$target = _ref.target,
      offsetHeight = _ref$target.offsetHeight,
      scrollHeight = _ref$target.scrollHeight,
      scrollTop = _ref$target.scrollTop;
  var atBottom = scrollHeight - scrollTop - offsetHeight <= 0;
  var atTop = scrollTop <= 0;
  var atEnd = mode === 'top' ? atTop : atBottom;
  return {
    atBottom: atBottom,
    atEnd: atEnd,
    atStart: !atEnd,
    atTop: atTop
  };
}

var Composer =
/*#__PURE__*/
function (_React$Component) {
  _inherits(Composer, _React$Component);

  function Composer(props) {
    var _this;

    _classCallCheck(this, Composer);

    _this = _possibleConstructorReturn(this, _getPrototypeOf(Composer).call(this, props));
    _this.handleScroll = _this.handleScroll.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this.handleScrollEnd = _this.handleScrollEnd.bind(_assertThisInitialized(_assertThisInitialized(_this)));
    _this._ignoreScrollEventBefore = 0;
    _this.state = {
      functionContext: {
        scrollTo: function scrollTo(scrollTop) {
          return _this.setState(function (_ref2) {
            var stateContext = _ref2.stateContext;
            return {
              scrollTop: scrollTop,
              stateContext: (0, _simpleUpdateIn.default)(stateContext, ['animating'], function () {
                return true;
              })
            };
          });
        },
        scrollToBottom: function scrollToBottom() {
          return _this.state.functionContext.scrollTo('100%');
        },
        scrollToEnd: function scrollToEnd() {
          var _assertThisInitialize = _assertThisInitialized(_assertThisInitialized(_this)),
              _assertThisInitialize2 = _assertThisInitialize.state,
              functionContext = _assertThisInitialize2.functionContext,
              stateContext = _assertThisInitialize2.stateContext;

          stateContext.mode === 'top' ? functionContext.scrollToTop() : functionContext.scrollToBottom();
        },
        scrollToStart: function scrollToStart() {
          var _assertThisInitialize3 = _assertThisInitialized(_assertThisInitialized(_this)),
              _assertThisInitialize4 = _assertThisInitialize3.state,
              functionContext = _assertThisInitialize4.functionContext,
              stateContext = _assertThisInitialize4.stateContext;

          stateContext.mode === 'top' ? functionContext.scrollToBottom() : functionContext.scrollToTop();
        },
        scrollToTop: function scrollToTop() {
          return _this.state.functionContext.scrollTo(0);
        }
      },
      internalContext: {
        setTarget: function setTarget(target) {
          return _this.setState(function () {
            return {
              target: target
            };
          });
        }
      },
      scrollTop: props.mode === 'top' ? 0 : '100%',
      stateContext: {
        animating: false,
        atBottom: true,
        atEnd: true,
        atTop: true,
        mode: props.mode,
        sticky: true
      },
      target: null
    };
    return _this;
  }

  _createClass(Composer, [{
    key: "componentDidMount",
    value: function componentDidMount() {
      this.enableWorker();
    }
  }, {
    key: "disableWorker",
    value: function disableWorker() {
      clearInterval(this._stickyCheckTimeout);
    }
  }, {
    key: "enableWorker",
    value: function enableWorker() {
      var _this2 = this;

      clearInterval(this._stickyCheckTimeout);
      this._stickyCheckTimeout = setImmediateInterval(function () {
        var state = _this2.state;
        var sticky = state.stateContext.sticky,
            target = state.target;

        if (sticky && target) {
          var _computeViewState = computeViewState(state),
              atEnd = _computeViewState.atEnd;

          !atEnd && state.functionContext.scrollToEnd();
        }
      }, Math.max(MIN_CHECK_INTERVAL, this.props.checkInterval) || MIN_CHECK_INTERVAL);
    }
  }, {
    key: "componentWillUnmount",
    value: function componentWillUnmount() {
      this.disableWorker();
    }
  }, {
    key: "componentWillReceiveProps",
    value: function componentWillReceiveProps(nextProps) {
      this.setState(function (_ref3) {
        var stateContext = _ref3.stateContext;
        return {
          stateContext: _objectSpread({}, stateContext, {
            mode: nextProps.mode === 'top' ? 'top' : 'bottom'
          })
        };
      });
    }
  }, {
    key: "handleScroll",
    value: function handleScroll(_ref4) {
      var _this3 = this;

      var timeStampLow = _ref4.timeStampLow;

      // Currently, there are no reliable way to check if the "scroll" event is trigger due to
      // user gesture, programmatic scrolling, or Chrome-synthesized "scroll" event to compensate size change.
      // Thus, we use our best-effort to guess if it is triggered by user gesture, and disable sticky if it is heading towards the start direction.
      if (timeStampLow <= this._ignoreScrollEventBefore) {
        // Since we debounce "scroll" event, this handler might be called after spineTo.onEnd (a.k.a. artificial scrolling).
        // We should ignore debounced event fired after scrollEnd, because without skipping them, the userInitiatedScroll calculated below will not be accurate.
        // Thus, on a fast machine, adding elements super fast will lose the "stickiness".
        return;
      }

      this.disableWorker();
      this.setState(function (state) {
        var target = state.target;

        if (target) {
          var scrollTop = state.scrollTop,
              stateContext = state.stateContext;

          var _computeViewState2 = computeViewState(state),
              atBottom = _computeViewState2.atBottom,
              atEnd = _computeViewState2.atEnd,
              atStart = _computeViewState2.atStart,
              atTop = _computeViewState2.atTop;

          var nextStateContext = stateContext;
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atBottom'], function () {
            return atBottom;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atEnd'], function () {
            return atEnd;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atStart'], function () {
            return atStart;
          });
          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['atTop'], function () {
            return atTop;
          }); // Sticky means:
          // - If it is scrolled programatically, we are still in sticky mode
          // - If it is scrolled by the user, then sticky means if we are at the end

          nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['sticky'], function () {
            return stateContext.animating ? true : atEnd;
          }); // If no scrollTop is set (not in programmatic scrolling mode), we should set "animating" to false
          // "animating" is used to calculate the "sticky" property

          if (scrollTop === null) {
            nextStateContext = (0, _simpleUpdateIn.default)(nextStateContext, ['animating'], function () {
              return false;
            });
          }

          if (stateContext !== nextStateContext) {
            return {
              stateContext: nextStateContext
            };
          }
        }
      }, function () {
        _this3.state.stateContext.sticky && _this3.enableWorker();
      });
    }
  }, {
    key: "handleScrollEnd",
    value: function handleScrollEnd() {
      // We should ignore debouncing handleScroll that emit before this time
      this._ignoreScrollEventBefore = Date.now();
      this.setState(function () {
        return {
          scrollTop: null
        };
      });
    }
  }, {
    key: "render",
    value: function render() {
      var handleScroll = this.handleScroll,
          handleScrollEnd = this.handleScrollEnd,
          _this$props = this.props,
          children = _this$props.children,
          debounce = _this$props.debounce,
          _this$state = this.state,
          functionContext = _this$state.functionContext,
          internalContext = _this$state.internalContext,
          scrollTop = _this$state.scrollTop,
          stateContext = _this$state.stateContext,
          target = _this$state.target;
      return _react.default.createElement(_InternalContext.default.Provider, {
        value: internalContext
      }, _react.default.createElement(_FunctionContext.default.Provider, {
        value: functionContext
      }, _react.default.createElement(_StateContext.default.Provider, {
        value: stateContext
      }, children, target && _react.default.createElement(_EventSpy.default, {
        debounce: debounce,
        name: "scroll",
        onEvent: handleScroll,
        target: target
      }), target && scrollTop !== null && _react.default.createElement(_SpineTo.default, {
        name: "scrollTop",
        onEnd: handleScrollEnd,
        target: target,
        value: scrollTop
      }))));
    }
  }]);

  return Composer;
}(_react.default.Component);

exports.default = Composer;
Composer.defaultProps = {
  checkInterval: 150,
  debounce: 17
};
Composer.propTypes = {
  checkInterval: _propTypes.default.number,
  debounce: _propTypes.default.number
};
//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJzb3VyY2VzIjpbIi4uLy4uL3NyYy9TY3JvbGxUb0JvdHRvbS9Db21wb3Nlci5qcyJdLCJuYW1lcyI6WyJNSU5fQ0hFQ0tfSU5URVJWQUwiLCJzZXRJbW1lZGlhdGVJbnRlcnZhbCIsImZuIiwibXMiLCJzZXRJbnRlcnZhbCIsImNvbXB1dGVWaWV3U3RhdGUiLCJtb2RlIiwic3RhdGVDb250ZXh0IiwidGFyZ2V0Iiwib2Zmc2V0SGVpZ2h0Iiwic2Nyb2xsSGVpZ2h0Iiwic2Nyb2xsVG9wIiwiYXRCb3R0b20iLCJhdFRvcCIsImF0RW5kIiwiYXRTdGFydCIsIkNvbXBvc2VyIiwicHJvcHMiLCJoYW5kbGVTY3JvbGwiLCJiaW5kIiwiaGFuZGxlU2Nyb2xsRW5kIiwiX2lnbm9yZVNjcm9sbEV2ZW50QmVmb3JlIiwic3RhdGUiLCJmdW5jdGlvbkNvbnRleHQiLCJzY3JvbGxUbyIsInNldFN0YXRlIiwic2Nyb2xsVG9Cb3R0b20iLCJzY3JvbGxUb0VuZCIsInNjcm9sbFRvVG9wIiwic2Nyb2xsVG9TdGFydCIsImludGVybmFsQ29udGV4dCIsInNldFRhcmdldCIsImFuaW1hdGluZyIsInN0aWNreSIsImVuYWJsZVdvcmtlciIsImNsZWFySW50ZXJ2YWwiLCJfc3RpY2t5Q2hlY2tUaW1lb3V0IiwiTWF0aCIsIm1heCIsImNoZWNrSW50ZXJ2YWwiLCJkaXNhYmxlV29ya2VyIiwibmV4dFByb3BzIiwidGltZVN0YW1wTG93IiwibmV4dFN0YXRlQ29udGV4dCIsIkRhdGUiLCJub3ciLCJjaGlsZHJlbiIsImRlYm91bmNlIiwiUmVhY3QiLCJDb21wb25lbnQiLCJkZWZhdWx0UHJvcHMiLCJwcm9wVHlwZXMiLCJQcm9wVHlwZXMiLCJudW1iZXIiXSwibWFwcGluZ3MiOiI7Ozs7Ozs7QUFBQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFFQTs7QUFDQTs7QUFDQTs7QUFDQTs7QUFDQTs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFFQSxJQUFNQSxrQkFBa0IsR0FBRyxFQUEzQjs7QUFFQSxTQUFT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QUFLLEVBQUdTLGVBRlY7QUFHRSxRQUFBLE1BQU0sRUFBR1osTUFIWDtBQUlFLFFBQUEsS0FBSyxFQUFHRztBQUpWLFFBYk4sQ0FERixDQURGLENBREY7QUEyQkQ7Ozs7RUE3S21DcUMsZUFBTUMsUzs7O0FBZ0w1Q2pDLFFBQVEsQ0FBQ2tDLFlBQVQsR0FBd0I7QUFDdEJYLEVBQUFBLGFBQWEsRUFBRSxHQURPO0FBRXRCUSxFQUFBQSxRQUFRLEVBQUU7QUFGWSxDQUF4QjtBQUtBL0IsUUFBUSxDQUFDbUMsU0FBVCxHQUFxQjtBQUNuQlosRUFBQUEsYUFBYSxFQUFFYSxtQkFBVUMsTUFETjtBQUVuQk4sRUFBQUEsUUFBUSxFQUFFSyxtQkFBVUM7QUFGRCxDQUFyQiIsInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBtZW1vaXplIGZyb20gJ21lbW9pemUtb25lJztcbmltcG9ydCBQcm9wVHlwZXMgZnJvbSAncHJvcC10eXBlcyc7XG5pbXBvcnQgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHVwZGF0ZUluIGZyb20gJ3NpbXBsZS11cGRhdGUtaW4nO1xuXG5pbXBvcnQgRXZlbnRTcHkgZnJvbSAnLi4vRXZlbnRTcHknO1xuaW1wb3J0IEZ1bmN0aW9uQ29udGV4dCBmcm9tICcuL0Z1bmN0aW9uQ29udGV4dCc7XG5pbXBvcnQgSW50ZXJuYWxDb250ZXh0IGZyb20gJy4vSW50ZXJuYWxDb250ZXh0JztcbmltcG9ydCBTcGluZVRvIGZyb20gJy4uL1NwaW5lVG8nO1xuaW1wb3J0IFN0YXRlQ29udGV4dCBmcm9tICcuL1N0YXRlQ29udGV4dCc7XG5cbmNvbnN0IE1JTl9DSEVDS19JTlRFUlZBTCA9IDE3O1xuXG5mdW5jdGlvbiBzZXRJbW1lZGlhdGVJbnRlcnZhbChmbiwgbXMpIHtcbiAgZm4oKTtcblxuICByZXR1cm4gc2V0SW50ZXJ2YWwoZm4sIG1zKTtcbn1cblxuZnVuY3Rpb24gY29tcHV0ZVZpZXdTdGF0ZSh7IHN0YXRlQ29udGV4dDogeyBtb2RlIH0sIHRhcmdldDogeyBvZmZzZXRIZWlnaHQsIHNjcm9sbEhlaWdodCwgc2Nyb2xsVG9wIH0gfSkge1xuICBjb25zdCBhdEJvdHRvbSA9IHNjcm9sbEhlaWdodCAtIHNjcm9sbFRvcCAtIG9mZnNldEhlaWdodCA8PSAwO1xuICBjb25zdCBhdFRvcCA9IHNjcm9sbFRvcCA8PSAwO1xuICBjb25zdCBhdEVuZCA9IG1vZGUgPT09ICd0b3AnID8gYXRUb3AgOiBhdEJvdHRvbTtcblxuICByZXR1cm4ge1xuICAgIGF0Qm90dG9tLFxuICAgIGF0RW5kLFxuICAgIGF0U3RhcnQ6ICFhdEVuZCxcbiAgICBhdFRvcFxuICB9O1xufVxuXG5leHBvcnQgZGVmYXVsdCBjbGFzcyBDb21wb3NlciBleHRlbmRzIFJlYWN0LkNvbXBvbmVudCB7XG4gIGNvbnN0cnVjdG9yKHByb3BzKSB7XG4gICAgc3VwZXIocHJvcHMpO1xuXG4gICAgdGhpcy5oYW5kbGVTY3JvbGwgPSB0aGlzLmhhbmRsZVNjcm9sbC5iaW5kKHRoaXMpO1xuICAgIHRoaXMuaGFuZGxlU2Nyb2xsRW5kID0gdGhpcy5oYW5kbGVTY3JvbGxFbmQuYmluZCh0aGlzKTtcblxuICAgIHRoaXMuX2lnbm9yZVNjcm9sbEV2ZW50QmVmb3JlID0gMDtcblxuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBmdW5jdGlvbkNvbnRleHQ6IHtcbiAgICAgICAgc2Nyb2xsVG86IHNjcm9sbFRvcCA9PiB0aGlzLnNldFN0YXRlKCh7IHN0YXRlQ29udGV4dCB9KSA9PiAoe1xuICAgICAgICAgIHNjcm9sbFRvcCxcbiAgICAgICAgICBzdGF0ZUNvbnRleHQ6IHVwZGF0ZUluKHN0YXRlQ29udGV4dCwgWydhbmltYXRpbmcnXSwgKCkgPT4gdHJ1ZSlcbiAgICAgICAgfSkpLFxuICAgICAgICBzY3JvbGxUb0JvdHRvbTogKCkgPT4gdGhpcy5zdGF0ZS5mdW5jdGlvbkNvbnRleHQuc2Nyb2xsVG8oJzEwMCUnKSxcbiAgICAgICAgc2Nyb2xsVG9FbmQ6ICgpID0+IHtcbiAgICAgICAgICBjb25zdCB7IHN0YXRlOiB7IGZ1bmN0aW9uQ29udGV4dCwgc3RhdGVDb250ZXh0IH0gfSA9IHRoaXM7XG5cbiAgICAgICAgICBzdGF0ZUNvbnRleHQubW9kZSA9PT0gJ3RvcCcgPyBmdW5jdGlvbkNvbnRleHQuc2Nyb2xsVG9Ub3AoKSA6IGZ1bmN0aW9uQ29udGV4dC5zY3JvbGxUb0JvdHRvbSgpO1xuICAgICAgICB9LFxuICAgICAgICBzY3JvbGxUb1N0YXJ0OiAoKSA9PiB7XG4gICAgICAgICAgY29uc3QgeyBzdGF0ZTogeyBmdW5jdGlvbkNvbnRleHQsIHN0YXRlQ29udGV4dCB9IH0gPSB0aGlzO1xuXG4gICAgICAgICAgc3RhdGVDb250ZXh0Lm1vZGUgPT09ICd0b3AnID8gZnVuY3Rpb25Db250ZXh0LnNjcm9sbFRvQm90dG9tKCkgOiBmdW5jdGlvbkNvbnRleHQuc2Nyb2xsVG9Ub3AoKTtcbiAgICAgICAgfSxcbiAgICAgICAgc2Nyb2xsVG9Ub3A6ICgpID0+IHRoaXMuc3RhdGUuZnVuY3Rpb25Db250ZXh0LnNjcm9sbFRvKDApXG4gICAgICB9LFxuICAgICAgaW50ZXJuYWxDb250ZXh0OiB7XG4gICAgICAgIHNldFRhcmdldDogdGFyZ2V0ID0+IHRoaXMuc2V0U3RhdGUoKCkgPT4gKHsgdGFyZ2V0IH0pKVxuICAgICAgfSxcbiAgICAgIHNjcm9sbFRvcDogcHJvcHMubW9kZSA9PT0gJ3RvcCcgPyAwIDogJzEwMCUnLFxuICAgICAgc3RhdGVDb250ZXh0OiB7XG4gICAgICAgIGFuaW1hdGluZzogZmFsc2UsXG4gICAgICAgIGF0Qm90dG9tOiB0cnVlLFxuICAgICAgICBhdEVuZDogdHJ1ZSxcbiAgICAgICAgYXRUb3A6IHRydWUsXG4gICAgICAgIG1vZGU6IHByb3BzLm1vZGUsXG4gICAgICAgIHN0aWNreTogdHJ1ZVxuICAgICAgfSxcbiAgICAgIHRhcmdldDogbnVsbFxuICAgIH07XG4gIH1cblxuICBjb21wb25lbnREaWRNb3VudCgpIHtcbiAgICB0aGlzLmVuYWJsZVdvcmtlcigpO1xuICB9XG5cbiAgZGlzYWJsZVdvcmtlcigpIHtcbiAgICBjbGVhckludGVydmFsKHRoaXMuX3N0aWNreUNoZWNrVGltZW91dCk7XG4gIH1cblxuICBlbmFibGVXb3JrZXIoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLl9zdGlja3lDaGVja1RpbWVvdXQpO1xuXG4gICAgdGhpcy5fc3RpY2t5Q2hlY2tUaW1lb3V0ID0gc2V0SW1tZWRpYXRlSW50ZXJ2YWwoXG4gICAgICAoKSA9PiB7XG4gICAgICAgIGNvbnN0IHsgc3RhdGUgfSA9IHRoaXM7XG4gICAgICAgIGNvbnN0IHsgc3RhdGVDb250ZXh0OiB7IHN0aWNreSB9LCB0YXJnZXQgfSA9IHN0YXRlO1xuXG4gICAgICAgIGlmIChzdGlja3kgJiYgdGFyZ2V0KSB7XG4gICAgICAgICAgY29uc3QgeyBhdEVuZCB9ID0gY29tcHV0ZVZpZXdTdGF0ZShzdGF0ZSk7XG5cbiAgICAgICAgICAhYXRFbmQgJiYgc3RhdGUuZnVuY3Rpb25Db250ZXh0LnNjcm9sbFRvRW5kKCk7XG4gICAgICAgIH1cbiAgICAgIH0sXG4gICAgICBNYXRoLm1heChNSU5fQ0hFQ0tfSU5URVJWQUwsIHRoaXMucHJvcHMuY2hlY2tJbnRlcnZhbCkgfHwgTUlOX0NIRUNLX0lOVEVSVkFMXG4gICAgKTtcbiAgfVxuXG4gIGNvbXBvbmVudFdpbGxVbm1vdW50KCkge1xuICAgIHRoaXMuZGlzYWJsZVdvcmtlcigpO1xuICB9XG5cbiAgY29tcG9uZW50V2lsbFJlY2VpdmVQcm9wcyhuZXh0UHJvcHMpIHtcbiAgICB0aGlzLnNldFN0YXRlKCh7IHN0YXRlQ29udGV4dCB9KSA9PiAoe1xuICAgICAgc3RhdGVDb250ZXh0OiB7XG4gICAgICAgIC4uLnN0YXRlQ29udGV4dCxcbiAgICAgICAgbW9kZTogbmV4dFByb3BzLm1vZGUgPT09ICd0b3AnID8gJ3RvcCcgOiAnYm90dG9tJ1xuICAgICAgfVxuICAgIH0pKTtcbiAgfVxuXG4gIGhhbmRsZVNjcm9sbCh7IHRpbWVTdGFtcExvdyB9KSB7XG4gICAgLy8gQ3VycmVudGx5LCB0aGVyZSBhcmUgbm8gcmVsaWFibGUgd2F5IHRvIGNoZWNrIGlmIHRoZSBcInNjcm9sbFwiIGV2ZW50IGlzIHRyaWdnZXIgZHVlIHRvXG4gICAgLy8gdXNlciBnZXN0dXJlLCBwcm9ncmFtbWF0aWMgc2Nyb2xsaW5nLCBvciBDaHJvbWUtc3ludGhlc2l6ZWQgXCJzY3JvbGxcIiBldmVudCB0byBjb21wZW5zYXRlIHNpemUgY2hhbmdlLlxuICAgIC8vIFRodXMsIHdlIHVzZSBvdXIgYmVzdC1lZmZvcnQgdG8gZ3Vlc3MgaWYgaXQgaXMgdHJpZ2dlcmVkIGJ5IHVzZXIgZ2VzdHVyZSwgYW5kIGRpc2FibGUgc3RpY2t5IGlmIGl0IGlzIGhlYWRpbmcgdG93YXJkcyB0aGUgc3RhcnQgZGlyZWN0aW9uLlxuXG4gICAgaWYgKHRpbWVTdGFtcExvdyA8PSB0aGlzLl9pZ25vcmVTY3JvbGxFdmVudEJlZm9yZSkge1xuICAgICAgLy8gU2luY2Ugd2UgZGVib3VuY2UgXCJzY3JvbGxcIiBldmVudCwgdGhpcyBoYW5kbGVyIG1pZ2h0IGJlIGNhbGxlZCBhZnRlciBzcGluZVRvLm9uRW5kIChhLmsuYS4gYXJ0aWZpY2lhbCBzY3JvbGxpbmcpLlxuICAgICAgLy8gV2Ugc2hvdWxkIGlnbm9yZSBkZWJvdW5jZWQgZXZlbnQgZmlyZWQgYWZ0ZXIgc2Nyb2xsRW5kLCBiZWNhdXNlIHdpdGhvdXQgc2tpcHBpbmcgdGhlbSwgdGhlIHVzZXJJbml0aWF0ZWRTY3JvbGwgY2FsY3VsYXRlZCBiZWxvdyB3aWxsIG5vdCBiZSBhY2N1cmF0ZS5cbiAgICAgIC8vIFRodXMsIG9uIGEgZmFzdCBtYWNoaW5lLCBhZGRpbmcgZWxlbWVudHMgc3VwZXIgZmFzdCB3aWxsIGxvc2UgdGhlIFwic3RpY2tpbmVzc1wiLlxuXG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdGhpcy5kaXNhYmxlV29ya2VyKCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKHN0YXRlID0+IHtcbiAgICAgIGNvbnN0IHsgdGFyZ2V0IH0gPSBzdGF0ZTtcblxuICAgICAgaWYgKHRhcmdldCkge1xuICAgICAgICBjb25zdCB7IHNjcm9sbFRvcCwgc3RhdGVDb250ZXh0IH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgeyBhdEJvdHRvbSwgYXRFbmQsIGF0U3RhcnQsIGF0VG9wIH0gPSBjb21wdXRlVmlld1N0YXRlKHN0YXRlKTtcbiAgICAgICAgbGV0IG5leHRTdGF0ZUNvbnRleHQgPSBzdGF0ZUNvbnRleHQ7XG5cbiAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnYXRCb3R0b20nXSwgKCkgPT4gYXRCb3R0b20pO1xuICAgICAgICBuZXh0U3RhdGVDb250ZXh0ID0gdXBkYXRlSW4obmV4dFN0YXRlQ29udGV4dCwgWydhdEVuZCddLCAoKSA9PiBhdEVuZCk7XG4gICAgICAgIG5leHRTdGF0ZUNvbnRleHQgPSB1cGRhdGVJbihuZXh0U3RhdGVDb250ZXh0LCBbJ2F0U3RhcnQnXSwgKCkgPT4gYXRTdGFydCk7XG4gICAgICAgIG5leHRTdGF0ZUNvbnRleHQgPSB1cGRhdGVJbihuZXh0U3RhdGVDb250ZXh0LCBbJ2F0VG9wJ10sICgpID0+IGF0VG9wKTtcblxuICAgICAgICAvLyBTdGlja3kgbWVhbnM6XG4gICAgICAgIC8vIC0gSWYgaXQgaXMgc2Nyb2xsZWQgcHJvZ3JhbWF0aWNhbGx5LCB3ZSBhcmUgc3RpbGwgaW4gc3RpY2t5IG1vZGVcbiAgICAgICAgLy8gLSBJZiBpdCBpcyBzY3JvbGxlZCBieSB0aGUgdXNlciwgdGhlbiBzdGlja3kgbWVhbnMgaWYgd2UgYXJlIGF0IHRoZSBlbmRcbiAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnc3RpY2t5J10sICgpID0+IHN0YXRlQ29udGV4dC5hbmltYXRpbmcgPyB0cnVlIDogYXRFbmQpO1xuXG4gICAgICAgIC8vIElmIG5vIHNjcm9sbFRvcCBpcyBzZXQgKG5vdCBpbiBwcm9ncmFtbWF0aWMgc2Nyb2xsaW5nIG1vZGUpLCB3ZSBzaG91bGQgc2V0IFwiYW5pbWF0aW5nXCIgdG8gZmFsc2VcbiAgICAgICAgLy8gXCJhbmltYXRpbmdcIiBpcyB1c2VkIHRvIGNhbGN1bGF0ZSB0aGUgXCJzdGlja3lcIiBwcm9wZXJ0eVxuICAgICAgICBpZiAoc2Nyb2xsVG9wID09PSBudWxsKSB7XG4gICAgICAgICAgbmV4dFN0YXRlQ29udGV4dCA9IHVwZGF0ZUluKG5leHRTdGF0ZUNvbnRleHQsIFsnYW5pbWF0aW5nJ10sICgpID0+IGZhbHNlKTtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChzdGF0ZUNvbnRleHQgIT09IG5leHRTdGF0ZUNvbnRleHQpIHtcbiAgICAgICAgICByZXR1cm4geyBzdGF0ZUNvbnRleHQ6IG5leHRTdGF0ZUNvbnRleHQgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0sICgpID0+IHtcbiAgICAgIHRoaXMuc3RhdGUuc3RhdGVDb250ZXh0LnN0aWNreSAmJiB0aGlzLmVuYWJsZVdvcmtlcigpO1xuICAgIH0pO1xuICB9XG5cbiAgaGFuZGxlU2Nyb2xsRW5kKCkge1xuICAgIC8vIFdlIHNob3VsZCBpZ25vcmUgZGVib3VuY2luZyBoYW5kbGVTY3JvbGwgdGhhdCBlbWl0IGJlZm9yZSB0aGlzIHRpbWVcbiAgICB0aGlzLl9pZ25vcmVTY3JvbGxFdmVudEJlZm9yZSA9IERhdGUubm93KCk7XG5cbiAgICB0aGlzLnNldFN0YXRlKCgpID0+ICh7IHNjcm9sbFRvcDogbnVsbCB9KSk7XG4gIH1cblxuICByZW5kZXIoKSB7XG4gICAgY29uc3Qge1xuICAgICAgaGFuZGxlU2Nyb2xsLFxuICAgICAgaGFuZGxlU2Nyb2xsRW5kLFxuICAgICAgcHJvcHM6IHsgY2hpbGRyZW4sIGRlYm91bmNlIH0sXG4gICAgICBzdGF0ZTogeyBmdW5jdGlvbkNvbnRleHQsIGludGVybmFsQ29udGV4dCwgc2Nyb2xsVG9wLCBzdGF0ZUNvbnRleHQsIHRhcmdldCB9XG4gICAgfSA9IHRoaXM7XG5cbiAgICByZXR1cm4gKFxuICAgICAgPEludGVybmFsQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IGludGVybmFsQ29udGV4dCB9PlxuICAgICAgICA8RnVuY3Rpb25Db250ZXh0LlByb3ZpZGVyIHZhbHVlPXsgZnVuY3Rpb25Db250ZXh0IH0+XG4gICAgICAgICAgPFN0YXRlQ29udGV4dC5Qcm92aWRlciB2YWx1ZT17IHN0YXRlQ29udGV4dCB9PlxuICAgICAgICAgICAgeyBjaGlsZHJlbiB9XG4gICAgICAgICAgICB7XG4gICAgICAgICAgICAgIHRhcmdldCAmJlxuICAgICAgICAgICAgICAgIDxFdmVudFNweVxuICAgICAgICAgICAgICAgICAgZGVib3VuY2U9eyBkZWJvdW5jZSB9XG4gICAgICAgICAgICAgICAgICBuYW1lPVwic2Nyb2xsXCJcbiAgICAgICAgICAgICAgICAgIG9uRXZlbnQ9eyBoYW5kbGVTY3JvbGwgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PXsgdGFyZ2V0IH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgICAge1xuICAgICAgICAgICAgICB0YXJnZXQgJiYgc2Nyb2xsVG9wICE9PSBudWxsICYmXG4gICAgICAgICAgICAgICAgPFNwaW5lVG9cbiAgICAgICAgICAgICAgICAgIG5hbWU9XCJzY3JvbGxUb3BcIlxuICAgICAgICAgICAgICAgICAgb25FbmQ9eyBoYW5kbGVTY3JvbGxFbmQgfVxuICAgICAgICAgICAgICAgICAgdGFyZ2V0PXsgdGFyZ2V0IH1cbiAgICAgICAgICAgICAgICAgIHZhbHVlPXsgc2Nyb2xsVG9wIH1cbiAgICAgICAgICAgICAgICAvPlxuICAgICAgICAgICAgfVxuICAgICAgICAgIDwvU3RhdGVDb250ZXh0LlByb3ZpZGVyPlxuICAgICAgICA8L0Z1bmN0aW9uQ29udGV4dC5Qcm92aWRlcj5cbiAgICAgIDwvSW50ZXJuYWxDb250ZXh0LlByb3ZpZGVyPlxuICAgICk7XG4gIH1cbn1cblxuQ29tcG9zZXIuZGVmYXVsdFByb3BzID0ge1xuICBjaGVja0ludGVydmFsOiAxNTAsXG4gIGRlYm91bmNlOiAxN1xufTtcblxuQ29tcG9zZXIucHJvcFR5cGVzID0ge1xuICBjaGVja0ludGVydmFsOiBQcm9wVHlwZXMubnVtYmVyLFxuICBkZWJvdW5jZTogUHJvcFR5cGVzLm51bWJlclxufTtcbiJdfQ==